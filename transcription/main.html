<meta charset="UTF-8"/>

<html lang="">
<head>
    <title>Online IPA Phonetic Transcription</title>
    <meta charset="UTF-8">
    <meta name="Keywords" content="Online IPA Latin Phonetics Transcription"/>
    <meta name="description"
          content="Rule-base IPA phonetic transcription engine, which uses Wiktionary Lua pronunciation modules.">

    <script src="fengari-web.js" type="text/javascript"></script>
    <script>
        fengari.load('package.path = "modules/?.lua"')()
        fengari.load('mw = require "mw"')()
        fengari.load('libraryUtil = require "libraryUtil"')()
        fengari.load('require "mw-text"')()
        fengari.load('package.path = "modules/test/translit/?.lua"')()
        fengari.load('local m_debug = require "debug"')()
        fengari.load('export = require "la-pronunc"')()
        <!--        fengari.load('export = require "ru-pron"')()-->
        // fengari.load('export = require "pt-pronunc"')()


    </script>


    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
    <link
            href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&family=Voces&display=swap"
            rel="stylesheet"
    />


</head>
<body style="font-family: 'Voces', sans-serif">

<br/>


<form name="myForm">
    <div>
        Language:
    </div>
    <select class="dropdown" id="lang" onchange="giveSelection(this.value)">
        <option value="Latin" selected="selected">Latin</option>
        <option value="German">German</option>

    </select>
    <div>
        Additional options:
    </div>
    Style:
    <select class="dropdown" id="lang_style">
        <option data-option="Latin">Ecc</option>
        <option data-option="Latin">Classical</option>
        <option data-option="German">apple</option>

    </select>
    Form:
    <select class="dropdown" id="lang_form">
        <option data-option="Latin">Phonetic</option>
        <option data-option="Latin">Phonemic</option>
        <option data-option="German">Phonetic</option>

    </select>

</form>


<form id="frm1" onsubmit="return false">
    <div class="form-group">
                <textarea
                        id="text_to_transcribe"
                        name="text_to_transcribe"
                        required=""
                        autofocus=""
                        style="
                        height: 101px;
                        overflow: auto;
                        resize: vertical;
                        width: 500px;
                    "
                >
Hat Herr MÃ¼ller eine Frau? Ja, er hat eine Frau. Wie</textarea
                >
        <input type="button" id="clear_button"/>
        <div class="btn-group btn-block" role="group">
            <input
                    id="submit"
                    class="btn btn-primary btn-block"
                    name="submit"
                    type="submit"
                    value="Show transcription"
                    title="or Ctrl+Enter while in the text area"
            />
            <input
                    id="submit_by_line"
                    class="btn btn-primary btn-block"
                    name="submit"
                    type="button"
                    value="Show transcription line-by-line"
                    title="or Ctrl+Enter while in the text area"
            />
            <input
                    id="submit_by_col"
                    class="btn btn-primary btn-block"
                    name="submit"
                    type="button"
                    value="Show transcription column to column"
                    title="or Ctrl+Enter while in the text area"
            />
        </div>
    </div>
</form>

<table style="overflow: auto; resize: vertical; width: 500px">
    <tbody id="result"></tbody>
</table>
<pre id="output"></pre>
<script type="text/javascript">
    function sanitize(text) {
        console.log(text)
        return text.replace(/[^\p{L}]/gu, '')
    }

    function prepare_transcribe() {
        text = document.getElementById('text_to_transcribe').value
        textlines = text.split('\n')
        div = document.getElementById('result')
        div.innerHTML = ''
        return [div, textlines]
    }

    function transcribe() {

        [div, textlines] = prepare_transcribe()

        async function asyncMapStrict(arr, fn) {
            const result = [];

            for (let idx = 0; idx < arr.length; idx += 1) {
                const cur = arr[idx];
                await new Promise(resolve => setTimeout(resolve, 5));

                result.push(await fn(cur, idx, arr));
            }

            return result;
        }
        async function process_line(line) {

            separated = line.split(' ')
            div.insertAdjacentHTML('beforeend', '</br>')
            // result = separated.map((i) => get_ipa(i))
            function process_word(i){
                console.log('TEST1',i)
                result = get_ipa(i)
                console.log('TEST2',result)
                result = result.status === 'error'
                    ? `<span style="color:red">${result.value} </span>`
                    : `<span>${result.value} </span>`
                console.log('TEST3',result)
                div.insertAdjacentHTML('beforeend', result)

            }
            asyncMapStrict(separated, process_word)
        }

        asyncMapStrict(textlines, process_line)
    }

    function transcribe_by_line() {
        [div, textlines] = prepare_transcribe()

        function process_line(line) {
            separated = line.split(' ')
            result = separated.map((i) => get_ipa(i))
            result = result.map((i) =>
                i.status === 'error'
                    ? `<div style="color:red">${i.value} </div>`
                    : `<div>${i.value} </div>`
            )

            row = div.insertRow(-1)
            old = separated.map(
                (x) => `<div style="font-family: Garamond;">${x} </div>`
            )
            glued = result.map(
                (k, i) =>
                    '<div style="float:left;margin-left:5px;margin-top:5px;">' +
                    old[i] +
                    k +
                    '</div>'
            )
            glued
                .reverse()
                .map((x) => row.insertAdjacentHTML('afterbegin', x))
        }

        textlines.map(process_line)
    }

    function transcribe_by_column() {
        [div, textlines] = prepare_transcribe()

        function process_line(line) {
            separated = line.split(' ')
            result = separated.map((i) => get_ipa(i))
            result = result.map((i) =>
                i.status === 'error'
                    ? `<td style="color:red">${i.value} </td>`
                    : `<td>${i.value} </td>`
            )

            function insert_row(div, cells) {
                row = div.insertRow(-1)
                for (cell of cells) {
                    new_cell = row.insertCell(-1)
                    new_cell.outerHTML = cell
                }
            }

            old = separated.map(
                (x) => `<td style="font-family: Garamond;">${x} </td>`
            )
            result.map((k, i) => insert_row(div, [old[i], k]))
        }

        textlines.map(process_line)
    }

    var form = document.getElementById('frm1')

    form.addEventListener('submit', transcribe)
    document
        .getElementById('submit_by_line')
        .addEventListener('click', transcribe_by_line)
    document
        .getElementById('submit_by_col')
        .addEventListener('click', transcribe_by_column)

    document
        .getElementById('clear_button')
        .addEventListener('click', clear_input)

    function clear_input() {
        i = document.getElementById('text_to_transcribe')
        i.value = ''
    }

    function get_lang_style_form() {
        const lang = document.querySelector('#lang').value;
        const lang_style = document.querySelector('#lang_style').value;
        const lang_form = document.querySelector('#lang_form').value;

        return {lang, lang_style, lang_form}
    }

    function get_ipa(text) {

        const {lang, lang_style, lang_form} = get_lang_style_form()

        args = lang + ';' + lang_style + ';' + lang_form
        return get_ipa_cache(text, args)

    }

    function get_ipa_no_cache(text, args) {
        clean_text = sanitize(text)
        console.log(text)
        const [lang, lang_style, lang_form] = args.split(';')
        switch (lang) {
            case 'Latin':
                switch (lang_style) {
                    case 'Ecc':
                        switch (lang_form) {
                            case 'Phonetic':
                                command = `return (export.convert_words('${clean_text}',true,true,false))`

                                break;
                            case 'Phonemic':
                                command = `return (export.convert_words('${clean_text}',false,true,false))`
                                break;
                        }
                        break;
                    case 'Classical':
                        switch (lang_form) {
                            case 'Phonetic':
                                command = `return (export.convert_words('${clean_text}',true,false,false))`
                                break;
                            case 'Phonemic':
                                command = `return (export.convert_words('${clean_text}',false,false,false))`
                                break;
                        }
                        break;
                }

        }

        try {
            ipa = fengari.load(command)()
        } catch (err) {
            console.log(err)
            ipa = ''
        }
        split = text.split(/([\p{L}]+)/gu)
        index_in_split = split
            .map((x, n) => x === clean_text && n)
            .filter(Boolean)[0]

        split[index_in_split] = ipa

        console.log(text, ipa)
        if (!ipa) {
            return new Object({value: text, status: 'error'})
        }
        ipa = split.join('')
        console.log(args)

        return new Object({value: ipa, status: 'success'})
    }

    const memoizedFunction = (fn) => {
        let cache = {};
        return (value) => {
            if (value in cache) {
                console.log('Fetching from cache');
                return cache[value];
            } else {
                console.log('executing and fetching results');
                let result = fn(value);
                cache[value] = result;
                return result;
            }
        }
    }

    function memoizeLocalStorage(
        fn,
        options = {ttl: 100, backgroundRefresh: false},
    ) {
        if (!fn.name)
            throw new Error('memoizeLocalStorage only accepts non-anonymous functions');
        // Fetch localstorage or init new object
        const cache = JSON.parse(localStorage.getItem(fn.name) || '{}');

        //executes and caches result
        function executeAndCacheFn(fn, args, argsKey) {
            console.log(args)
            const result = fn(...args);
            // reset the cache value
            cache[fn.name] = {
                ...cache[fn.name],
                [argsKey]: {expiration: Date.now() + options.ttl, result},
            };
            console.log('Saving to cache', cache[fn.name])
            localStorage.setItem(fn.name, JSON.stringify(cache));
        }

        return function () {
            // Note: JSON.stringify is non-deterministic,
            // consider something like json-stable-stringify to avoid extra cache misses
            const argsKey = JSON.stringify(arguments);
            console.log('Key:',fn.name,argsKey)
            if (
                !cache[fn.name] ||
                !cache[fn.name][argsKey] ||
                cache[fn.name][argsKey].expiration >= Date.now()
            ) {
                executeAndCacheFn(fn, arguments, argsKey);
            } else if (options.backgroundRefresh) {
                console.log('Not found 2')
                executeAndCacheFn(fn, arguments, argsKey);
            }
            console.log('Find in cache!')
            return cache[fn.name][argsKey].result;
        };
    }

    const get_ipa_cache= memoizeLocalStorage(get_ipa_no_cache);


</script>

<script>


    var sel1 = document.querySelector('#lang');
    var sel2 = document.querySelector('#lang_style');
    var sel3 = document.querySelector('#lang_form');
    var options2 = sel2.querySelectorAll('option');
    var options3 = sel3.querySelectorAll('option');

    function giveSelection(selValue) {


        sel2.innerHTML = '';
        for (var i = 0; i < options2.length; i++) {
            if (options2[i].dataset.option === selValue) {
                sel2.appendChild(options2[i]);
            }
        }
        sel3.innerHTML = '';
        for (var i = 0; i < options3.length; i++) {
            if (options3[i].dataset.option === selValue) {
                sel3.appendChild(options3[i]);
            }
        }
    }


</script>
</body>
</html>