<meta charset="UTF-8"/>

<html lang="">
<head>
    <link href="https://cdn.jsdelivr.net/gh/yegor256/tacit@gh-pages/tacit-css-1.7.1.min.css" rel="stylesheet"/>

    <title>Free Online IPA Phonetic Transcription</title>
    <meta charset="UTF-8">
    <meta content="Online IPA Latin German Portuguese Phonetics Transcription" name="Keywords"/>
    <meta content="Free Online Rule-based IPA phonetic/phonemic transcription engine, which uses Wiktionary Lua pronunciation modules."
          name="description">
    <script src="wasmoon.js" type="text/javascript"></script>

    <script type="module">
        const factory = await lb.factory
        const lua = await factory.createEngine()

        // Set a JS function to be a global lua function
        lua.global.set('fetch', (url) => fetch(url));

        async function mountFile(file_path, lua_path) {
            const x = await fetch(file_path).then(data => data.text())
            await factory.mountFile(lua_path, x)
        }

        await mountFile('../wiktionary_pron/modules/memoize.lua', 'memoize.lua')
        await lua.doString(`
          memoize = require('memoize')
          function require(path)
              print('required '..path,'from:', debug.getinfo(2).name)
              if select(2,string.gsub(path, "%.", "")) > 0 then
                   new_path = string.gsub(path,"%.", "/",1)
                   print('replacing ', path,'->', new_path)
                   path = new_path
              end
              local resp = fetch(string.format('../wiktionary_pron/modules/%s.lua',path) ):await()
              local text = resp:text():await()
              local module =  load(text)()
              print('loaded '..path)
              return module
          end

          require = memoize(require)
          require('debug/track')
          require('ustring/charsets')
          require('ustring/lower')
          require('mw-title')
          require('ustring/normalization-data')
        `);
        console.log(lua)
        window.lua = lua
    </script>
    <script>
        async function loadLanguage(code) {
            const lua = window.lua
            console.log(lua)
            await lua.doString(`${code} = require("${code}-pron_wasm")`)
            // Get a global lua function as a JS function
            window[code + '_ipa'] = lua.global.get(code)

            // Set a JS function to be a global lua function
        }
    </script>

    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="favicon.ico" rel="shortcut icon" type="image/x-icon"/>
    <link
            href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@300&family=Voces&display=swap"
            rel="stylesheet"
    />


</head>
<body style="font-family: 'Voces', sans-serif">
<div id="content" style="font-size: 16pt; text-align: center">
    <br/>
    <h1 style="margin-top: 0px;">Online IPA Converter</h1>
    <hr>

    <form name="myForm">
        <div>
            Language:
        </div>
        <select autocomplete="off" class="dropdown" id="lang" onchange="giveSelection(this.value)">
            <option disabled selected value> -- select an option --</option>


        </select>
        <div>
            Additional options:
        </div>
        Style:
        <select autocomplete="off" class="dropdown" disabled="true" id="lang_style">
            <option disabled selected value> --</option>


        </select>
        Form:
        <select autocomplete="off" class="dropdown" disabled="true" id="lang_form">
            <option disabled selected value> --</option>


        </select>


    </form>


    <form id="frm1" onsubmit="return false">
        <div class="form-group">
            <div style="display: flex;
    margin-left: auto;
    margin-right: auto;
    max-width: 800px;
    align-content: center;
    flex-wrap: nowrap;
    flex-direction: row;
    align-items: flex-start;
    justify-content: space-between;">
                <textarea
                        autofocus=""
                        id="text_to_transcribe"
                        name="text_to_transcribe"
                        required=""
                        style="
                        height: 101px;
                        overflow: auto;
                        resize: vertical;
                        width: 500px;
                    "
                >Omnium provinciarum populi Romani quibus finitimae fuerunt gentes quae non parerent imperio nostro fines auxi. Gallias et Hispanias provincias, item Germaniam, qua includit Oceanus a Gadibus ad ostium Albis fluminis pacavi. Alpes a regione ea quae proxima est Hadriano mari ad Tuscum pacificavi nulli genti bello per iniuriam inlato. Classis mea per Oceanum ab ostio Rheni ad solis orientis regionem usque ad fines Cimbrorum navigavit, quo neque terra neque mari quisquam Romanus ante id tempus adit. Cimbrique et Charydes et Semnones et eiusdem tractus alii Germanorum populi per legatos amicitiam meam et populi Romani petierunt. Meo iussu et auspicio ducti sunt duo exercitus eodem fere tempore in Aethiopiam et in Arabiam quae appellatur Eudaemon, magnaeque hostium gentis utriusque copiae caesae sunt in acie et complura oppida capta. In Aethiopiam usque ad oppidum Nabata perventum est, cui proxima est Meroe; in Arabiam usque in fines Sabaeorum processit exercitus ad oppidum Mariba.

                    [27] Aegyptum imperio populi Romani adieci. Armeniam maiorem interfecto rege eius Artaxe cum possem facere provinciam malui maiorum nostrorum exemplo regnum id Tigrani regis Artavasdis filio, nepoti autem Tigranis regis, per Ti. Neronem tradere, qui tum mihi privignus erat. Et eandem gentem postea desciscentem et rebellantem domitam per Gaium filium meum regi Ariobarzani regis Medorum Artabazi filio regendam tradidi, et post eius mortem filio eius Artavasdi; quo interfecto Tigranem qui erat ex regio genere Armeniorum oriundus in id regnum misi. Provincias omnis quae trans Hadrianum mare vergunt ad orientem Cyrenasque, iam ex parte magna regibus ea possidentibus, et antea Siciliam et Sardiniam occupatas bello servili reciperavi.

                    </textarea>
                <button id="clear_button" type="button" value='Clear form'>Clear form</button>
                <button id="clear_storage" type="button" value="Clear cache">Clear cache</button>
            </div>
            <div class="btn-group btn-block" role="group" style="
    display: flex;
    flex-direction: row;
    align-content: stretch;
    flex-wrap: nowrap;
    justify-content: center;
    align-items: center;
">
                <input
                        autocomplete="off"
                        class="btn btn-primary btn-block"
                        disabled="disabled"
                        id="submit"
                        name="submit"
                        title="or Ctrl+Enter while in the text area"
                        type="button"
                        value="Show transcription"
                />
                <input
                        autocomplete="off"
                        class="btn btn-primary btn-block"
                        disabled="disabled"
                        id="submit_by_line"
                        name="submit"
                        title="or Ctrl+Enter while in the text area"
                        type="button"
                        value="Show transcription line-by-line"
                />
                <input
                        autocomplete="off"
                        class="btn btn-primary btn-block"
                        disabled="disabled"
                        id="submit_by_col"
                        name="submit"
                        title="or Ctrl+Enter while in the text area"
                        type="button"
                        value="Show transcription column to column"
                />
            </div>
        </div>
    </form>
    <hr>
    <table style="overflow: auto; resize: vertical; max-width: 1000px; font-size: 20pt;   margin-left: auto;margin-right: auto;">
        <tbody id="result"></tbody>
    </table>

</div>
<script type="text/javascript">
    function sanitize(text) {
        return text.replace(/[^\p{L}]/gu, '')
    }

    /**
     * Splits the input text into chunks of maximum length.
     *
     * @param {string} text - The input text to split.
     * @param {number} maxChunkLength - The maximum length of each chunk.
     * @returns {string[]} - An array of chunks of the input text.
     */
    function splitTextIntoChunks(text, maxChunkLength) {
        const wordsAndNewlines = text.match(/\S+|\n/g);
        let chunks = [];
        let currentChunk = '';

        for (let i = 0; i < wordsAndNewlines.length; i++) {
            if (wordsAndNewlines[i] === '\n') {
                if (currentChunk !== '') {
                    chunks.push(currentChunk);
                    currentChunk = '';
                }
                continue;
            }

            if ((currentChunk + wordsAndNewlines[i]).length < maxChunkLength) {
                if (currentChunk !== '') {
                    currentChunk += ' ';
                }
                currentChunk += wordsAndNewlines[i];
            } else {
                chunks.push(currentChunk);
                currentChunk = wordsAndNewlines[i];
            }
        }

        if (currentChunk !== '') {
            chunks.push(currentChunk);
        }

        return chunks;
    }


    function prepareTranscribe() {
        text = document.getElementById('text_to_transcribe').value
        textlines = text.split('\n')
        //textlines = splitTextIntoChunks(text, maxChunkLength = 51)
        div = document.getElementById('result')
        div.innerHTML = ''
        return [div, textlines]
    }

    async function asyncMapStrict(arr, fn) {
        const result = [];
        // console.time("Elapsed time :");
        for (let idx = 0; idx < arr.length; idx += 1) {
            const cur = arr[idx];
            await new Promise(resolve => setTimeout(resolve, 0.0001));

            result.push(await fn(cur, idx, arr));
        }
        // console.timeEnd("Elapsed time :")
        return result;
    }

    async function wait(ms = 1) {
        await new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * Transcribes the text and shows the result in the result div based on the selected presentation mode.
     * @param {string} mode - The mode for transcribing the text (default, line, column).
     */
    async function transcribe(mode) {

        disableAll()
        try {
            [div, textlines] = prepareTranscribe()
            const {lang, langStyle, langForm} = getLangStyleForm()

            async function process_default(line) {
                separated = line.split(' ')
                div.insertAdjacentHTML('beforeend', '</br>')

                function process_word(i) {
                    const {status, value} = getIpa(i, lang, langStyle, langForm);
                    const color = status === 'error' ? 'red' : 'black';
                    const span = document.createElement('span');
                    span.style.color = color;
                    span.appendChild(document.createTextNode(value + ' '));
                    div.appendChild(span);
                }

                await Promise.all(separated.map(async function (x) {
                    await wait(1);
                    await process_word(x)
                }))


            }

            async function process_line(line) {
                const words = line.split(' ');
                const results = await Promise.all(words.map(async function (word) {
                    await wait(1);
                    return await getIpa(word, lang, langStyle, langForm);
                }));

                const formattedResults = results.map((result) =>
                    result.status === 'error'
                        ? `<div style="color:red">${result.value} </div>`
                        : `<div>${result.value} </div>`
                );

                const newRow = div.insertRow(-1);
                const formattedWords = words.map(
                    (word) => `<div style="font-family: Garamond;">${word} </div>`
                );
                const combinedResults = formattedResults.map(
                    (formattedResult, index) =>
                        '<div style="float:left;margin-left:5px;margin-top:5px;">' +
                        formattedWords[index] +
                        formattedResult +
                        '</div>'
                );
                combinedResults
                    .reverse()
                    .map((r) => newRow.insertAdjacentHTML('afterbegin', r));
            }

            async function process_column(line) {
                separated = line.split(' ')
                result = await Promise.all(separated.map(async function (x) {
                    await wait(1);
                    return await getIpa(x, lang, langStyle, langForm)
                }))

                result = result.map((i) =>
                    i.status === 'error'
                        ? `<td style="color:red">${i.value} </td>`
                        : `<td>${i.value} </td>`
                )

                function insert_row(div, cells) {
                    row = div.insertRow(-1)
                    for (cell of cells) {
                        new_cell = row.insertCell(-1)
                        new_cell.outerHTML = cell
                    }
                }

                old = separated.map(
                    (x) => `<td style="font-family: Garamond;">${x} </td>`
                )
                result.map((k, i) => insert_row(div, [old[i], k]))
            }

            switch (mode) {
                case 'default':
                    func = process_default
                    break
                case 'line':
                    func = process_line
                    break
                case 'column':
                    func = process_column
                    break
            }

            console.time()
            await asyncMapStrict(textlines, func)
            console.timeEnd()
            console.log('finished')
        } catch (err) {
            console.log(err)
        } finally {
            console.log('finally')
            enableAll()
        }

    }

    /**
     * Disables all form elements on the page
     */
    function disableAll() {
        // Select all the forms on the page
        const forms = Array.from(document.querySelectorAll('form'));

        // Iterate through each form and disable all its elements
        forms.forEach(form => {
            Array.from(form.elements).forEach(element => {
                element.disabled = true;
            });
        });
    }

    function enableAll() {
        // Get all the form elements on the page
        const forms = Array.from(document.querySelectorAll('form'));
        forms.forEach(form => {
            // Enable all elements in the form
            Array.from(form.elements).forEach(element => {
                element.disabled = false;
            });
        });
    }


    var form = document.getElementById('frm1')

    form.addEventListener('submit', (() => transcribe(mode = 'default')));
    document
        .getElementById('submit_by_line')
        .addEventListener('click', (() => transcribe(mode = 'line')))
    document
        .getElementById('submit_by_col')
        .addEventListener('click', (() => transcribe(mode = 'column')))

    document
        .getElementById('clear_button')
        .addEventListener('click', clear_input)

    document
        .getElementById('clear_storage')
        .addEventListener('click', clear_storage)

    function clear_storage() {
        const cache = JSON.parse(localStorage.getItem("get_ipa_no_cache") || '{}');
        cache["get_ipa_no_cache"] = ""
        localStorage.setItem("get_ipa_no_cache", JSON.stringify(cache));
    }

    function clear_input() {
        i = document.getElementById('text_to_transcribe')
        i.value = ''
    }

    /**
     * Retrieves the language, style, and form data from the DOM
     * @returns {Object} An object containing the language, language style, and language form data
     */
    function getLangStyleForm() {
        const lang = document.querySelector('#lang').value;
        const langStyle = document.querySelector('#lang_style').value;
        const langForm = document.querySelector('#lang_form').value;

        return {lang, langStyle, langForm}
    }

    /**
     * Retrieve the International Phonetic Alphabet (IPA) for the given text in the specified language.
     *
     * @param {string} text - The input text for which IPA needs to be retrieved.
     * @param {string} lang - The language of the input text.
     * @param {string} lang_style - The style (dialect) of the language.
     * @param {string} lang_form - The form (phonetic or phonemic) of the transcription.
     * @returns {string} - The IPA representation of the input text.
     */
    function getIpa(text, lang, lang_style, lang_form) {
        // Concatenate the language, style, and form parameters
        let args = lang + ';' + lang_style + ';' + lang_form;
        // Call memoized get_ipa_cache function to retrieve the IPA representation
        return get_ipa_cache(text, args);
    }

    function get_ipa_no_cache(text, args) {
        console.log('doing actual IPA', text, args)
        cleanText = sanitize(text)

        const [lang, langStyle, langForm] = args.split(';')
        let command = ''

        switch (lang) {
            case 'Latin':
                switch (langStyle) {
                    case 'Ecc':
                        command = langForm === 'Phonetic' ? `(window.la_ipa.convert_words('${cleanText}',true,true,false))` : `(window.la_ipa.convert_words('${cleanText}',false,true,false)`
                        break;
                    case 'Classical':
                        command = langForm === 'Phonetic' ? `(window.la_ipa.convert_words('${cleanText}',true,false,false))` : `(window.la_ipa.convert_words('${cleanText}',false,false,false)`
                        break;
                }
                break;
            case 'German':
                command = langForm === 'Phonetic' ? `(window.de_ipa.phonetic('${cleanText}'))` : `(window.de_ipa.phonemic('${cleanText}'))`
                break;
            case 'Portuguese':
                command = langStyle === 'Brazil' ? `window.pt_ipa.IPA('${cleanText}',"rio")[0].${langForm.toLowerCase()}` : `window.pt_ipa.IPA('${cleanText}',"pt")[0].${langForm.toLowerCase()}`
                break;
            case 'Spanish':
                dialect = langStyle === 'Castilian' ? 'distincion-yeismo' : 'seseo-yeismo'
                command = `window.es_ipa.IPA('${cleanText}','${dialect}', ${langForm === 'Phonetic'}).text`
                break;
            case 'French':
                if (langForm === 'Phonemic') {
                    command = `(window.fr_ipa.show('${cleanText}')[0])`
                }
                break;
            case 'Ukrainian':
                if (langForm === 'Phonetic') {
                    command = `(window.uk_ipa.pronunciation('${cleanText}',true))`
                }
                break;
            case 'Russian':
                if (langForm === 'Phonetic') {
                    command = `(window.ru_ipa.ipa_string('${cleanText}'))`
                }
                break;
            case 'Italian':
                if (langForm === 'Phonemic') {
                    command = `(window.it_ipa.to_phonemic('${cleanText}','TEST').phonemic)`
                }
                break;
        }

        let ipa = ''
        try {
            ipa = eval(command)
        } catch (err) {
            ipa = ''
        }

        const split = text.split(/([\p{L}]+)/gu)
        const indexInSplit = split.findIndex((x) => x === cleanText)

        split[indexInSplit] = ipa

        if (!ipa) {
            return {value: text, status: 'error'}
        }

        ipa = split.join('')
        return {value: ipa, status: 'success'}
    }


    /**
     * Memoizes the given function in local storage.
     * @param {Function} fn - The function to memoize.
     * @param {Object} options - Memoization options.
     * @param {number} options.ttl - Time to live for cached results in milliseconds.
     * @param {boolean} options.backgroundRefresh - Whether to refresh the cache in the background.
     * @throws {Error} Throws an error if the function is anonymous.
     * @returns {Function} Returns the memoized function.
     */
    function memoizeLocalStorage(
        fn,
        options = {ttl: 100, backgroundRefresh: false},
    ) {
        if (!fn.name)
            throw new Error('memoizeLocalStorage only accepts non-anonymous functions');
        // Fetch localstorage or init new object
        cache = JSON.parse(localStorage.getItem(fn.name) || '{}');

        //executes and caches result
        function executeAndCacheFn(fn, args, argsKey) {

            const result = fn(...args);
            // reset the cache value
            cache[fn.name] = {
                ...cache[fn.name],
                [argsKey]: {expiration: Date.now() + options.ttl, result},
            };

            localStorage.setItem(fn.name, JSON.stringify(cache));
        }

        return function () {
            // Note: JSON.stringify is non-deterministic,
            // consider something like json-stable-stringify to avoid extra cache misses

            const argsKey = JSON.stringify(arguments);

            if (
                !cache[fn.name] ||
                !cache[fn.name][argsKey] ||
                cache[fn.name][argsKey].expiration >= Date.now()
            ) {
                executeAndCacheFn(fn, arguments, argsKey);
                return cache[fn.name][argsKey].result;
            } else if (options.backgroundRefresh) {
                executeAndCacheFn(fn, arguments, argsKey);
                return cache[fn.name][argsKey].result;
            }
            console.log('Using cached', argsKey)

            return cache[fn.name][argsKey].result;
        };
    }


    const get_ipa_cache = memoizeLocalStorage(get_ipa_no_cache);


</script>

<script>

    languages = {
        Latin: {
            styles: ["Classical", "Ecc"],
            forms: ["Phonetic", "Phonemic"],
            langCode: "la",
        },
        German: {
            styles: ["Default"],
            forms: ["Phonetic", "Phonemic"],
            langCode: "de",
        },
        Portuguese: {
            styles: ["Brazil", "Portugal"],
            forms: ["Phonetic", "Phonemic"],
            langCode: "pt",
        }, Spanish: {
            styles: ["Castilian", "Latin_American "],
            forms: ["Phonetic", "Phonemic"],
            langCode: "es",
        },
        French: {styles: ["Default"], forms: ["Phonemic"], langCode: "fr"},
        Russian: {styles: ["Default"], forms: ["Phonetic"], langCode: "ru"},
        Ukrainian: {styles: ["Default"], forms: ["Phonetic"], langCode: "uk"},
    };

    var sel1 = document.querySelector("#lang");
    var sel2 = document.querySelector("#lang_style");
    var sel3 = document.querySelector("#lang_form");
    Object.entries(languages).map(function (args) {
        var lang = args[0];
        var opt = document.createElement("option");
        opt.value = lang;
        opt.text = lang;
        sel1.appendChild(opt);

        for (var i = 0; i < args[1].styles.length; i++) {
            var opt = document.createElement("option");
            opt.setAttribute("data-option", lang);
            opt.text = args[1].styles[i];
            sel2.appendChild(opt);
        }
        for (var i = 0; i < args[1].forms.length; i++) {
            var opt = document.createElement("option");
            opt.setAttribute("data-option", lang);
            opt.text = args[1].forms[i];
            sel3.appendChild(opt);
        }
    });
    var options2 = sel2.querySelectorAll('option');
    var options3 = sel3.querySelectorAll('option');

    var sel1 = document.querySelector('#lang');
    var sel2 = document.querySelector('#lang_style');
    var sel3 = document.querySelector('#lang_form');

    loadedLanguages = {}


    async function giveSelection(selValue) {


        if (!(selValue in loadedLanguages)) {
            const langCode = languages[selValue].langCode;
            disableAll();
            await loadLanguage(langCode);
            enableAll();
            loadedLanguages[selValue] = true;
        }

        sel2.innerHTML = '';
        for (const option of options2) {
            if (option.dataset.option === selValue) {
                sel2.appendChild(option);
            }
        }
        sel2.disabled = false;

        sel3.innerHTML = '';
        for (const option of options3) {
            if (option.dataset.option === selValue) {
                sel3.appendChild(option);
            }
        }
        sel3.disabled = false;
    }


</script>
</body>
</html>